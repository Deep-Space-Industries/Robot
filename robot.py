# -*- coding: utf-8 -*-
"""Untitled2.ipynb
Automatically generated by Colaboratory.
Original file is located at
    https://colab.research.google.com/drive/1p0wiwYiEdg_C6CbTCgy04KCG4aLr1xuH
"""
import pygame
import random
import math
import numpy as np
import pygame.gfxdraw as gfxdraw

WHITE = (255, 255, 255)
GREEN = (20, 255, 140)
GREY = (210, 210, 210)
RED = (255, 0, 0)
PURPLE = (255, 0, 255)
BLACK = (0, 0, 0)
BLUE = (0, 0, 255)
GOLD = (255,215,0)
SILVER = (192, 192, 192)
LIGHTBLUE = (135,206,250)

scaler = 10
PI = np.pi
cos = np.cos
sin = np.sin
tan = np.tan
arctan = np.arctan
decrease_factor = 1
increase_factor = 1

class Robot:
    def __init__(self, x, y, left_velocity, right_velocity, radius, walls):
        self.x = x
        self.y = y
        self.radius = radius
        self.history = []
        self.color = GREEN
        self.left_velocity = left_velocity
        self.right_velocity = right_velocity
        self.velocity = (self.left_velocity + self.right_velocity) / 2
        self.theta = 0
        self.thetarecord = []
        # self.omega=((self.right_velocity-self.left_velocity))/(2*self.radius)
        # self.icc_radius = self.radius * (self.left_velocity + self.right_velocity) / (self.right_velocity-self.left_velocity + 0.00001)
        # self.icc_centre_x=self.x-self.icc_radius*sin(self.theta)
        # self.icc_centre_y=self.y+self.icc_radius*cos(self.theta)
        self.omega = None
        self.icc_radius = None
        self.icc_centre_x = None
        self.icc_centre_y = None
        self.t = 0
        self.update_icc()
        self.decrease_factor = 1
        self.increase_factor = 1
        self.walls = walls
        self.collision = None
        self.collided_wall = None

    def calculate_to_sensor_distance(self,centre,sensor_point):
        m1= (sensor_point[1]-centre[1])/(sensor_point[0]-centre[0])
        c1=(sensor_point[0]*centre[1]-centre[0]*sensor_point[1])/(sensor_point[0]-centre[0])
        for wall in self.walls:
            wall_distance_list=[]
            m2=0
            c2=0
            intersection_point_x=None
            intersection_point_y=None
            if wall.end_point[0]!= wall.start_point[0]:
                m2=(wall.end_point[1]-wall.start_point[1])/(wall.end_point[0]-wall.start_point[0])
                c2=(wall.end_point[0]*wall.start_point[1]-wall.start_point[0]*wall.end_point[1])/(wall.end_point[0]-wall.start_point[0])
            else:
                m2=math.inf
                c2=math.inf
            if(m1 !=m2):
                intersection_point_x=(c2-c1)/(m1-m2)
                intersection_point_y=(m1*c2-m2*c1)/(m1-m2)

                min_x= min(wall.start_point[0],wall.end_point[0])
                max_x=max(wall.start_point[0],wall.end_point[0])
                min_y= min(wall.start_point[1],wall.end_point[1])
                max_y =max(wall.start_point[1],wall.end_point[1])
                if(min_y<= intersection_point_y and max_y>=intersection_point_y and min_x <= intersection_point_x and max_x >=intersection_point_x ):
                    wall_distance_list.append(np.sqrt(((intersection_point_y-sensor_point[1])**2) + ((intersection_point_x-sensor_point[0])**2)))
                    return min(wall_distance_list)
                else:
                    return None
            else:
                return math.inf

    def draw(self):
        font = pygame.font.SysFont('FUTURA', 16)
        if len(self.history) > 10:
            # color1 = 10
            # for i, h in enumerate(self.history[:-2]):
            #     color1 = int((color1 + 3) & 255)
            #     pygame.draw.aaline(screen, (color1, color1, 100), self.history[i], self.history[i + 1])
            for i, h in enumerate(self.history[2:-2]):
                pygame.draw.line(screen, BLACK, self.history[i], self.history[i+1], 3)
            # pygame.draw.aalines(screen, PURPLE, False, self.history[history_size - int(history_size / 3): history_size])
        # self.rect = pygame.rect.Rect((self.x, self.y, self.width, self.height))
        # pygame.draw.rect(screen, GREEN, self.rect)
        # self.rect = pygame.circ.Rect((self.x, self.y, self.width, self.height))
        # pygame.draw.circle(screen, GREEN, [self.x,self.y], self.radius)
        gfxdraw.aacircle(screen, int(round(self.x)), int(round(self.y)), self.radius, self.color)
        gfxdraw.filled_circle(screen, int(round(self.x)), int(round(self.y)), self.radius, self.color)
        self.history.append([int(round(self.x)), int(round(self.y))])
        self.thetarecord.append(self.theta)
        # print(f"x, y: {[self.x, self.y]}")
        angle = 0
        while (angle <= 360):
            # pygame.draw.line(screen, BLUE, (self.x + self.radius * cos(self.theta + angle * PI / 180),
            #                                 self.y + self.radius * sin(self.theta + angle * PI / 180)), \
            #                  (self.x + (self.radius + 10) * cos(self.theta + angle * PI / 180),
            #                   self.y + (self.radius + 10) * sin(self.theta + angle * PI / 180)), 2)
            pygame.draw.circle(screen, BLUE, (
                int(round(self.x + self.radius * cos(self.theta + angle * PI / 180))),
                int(round(self.y + self.radius * sin(self.theta + angle * PI / 180)))
            ), 2)
            self.collision_detection(self.x, self.y, False)
            print(f"near {self.nearest_dist}")
            # print(f"c {cos(angle)}")
            value = (self.nearest_dist / cos(np.deg2rad(angle))) - self.radius
            print(f"value {value}")
            # if 89 < angle < 271:
            #     value = None

            # value=self.calculate_to_sensor_distance([self.x,self.y],[self.x + self.radius * cos(self.theta + angle * PI / 180), \
            #                                                          self.y + self.radius * sin(self.theta + angle * PI / 180)])
            if (value != None and 0 <= value <= 300 ):
                print(value)
                rvalue = round(value)
                text = font.render(f"{rvalue}", True, BLACK)
                textRect = text.get_rect()
                textRect.center = (self.x + 2 * self.radius * cos(self.theta + angle * PI / 180), \
                                   self.y + 2 * self.radius * sin(self.theta + angle * PI / 180))

                screen.blit(text, textRect)

            angle = angle + 30

    def draw_icc(self):
        if (self.left_velocity == self.right_velocity):
            return
        pygame.draw.circle(screen, PURPLE, [int(self.icc_centre_x), int(self.icc_centre_y)], 2)
        # print(f"icc x y: {[int(self.icc_centre_x), int(self.icc_centre_y)]}")

    def draw_direction(self):
        rot = (self.x + self.radius * cos(self.theta), self.y + self.radius * sin(self.theta))
        # my_group.update(self.x, self.y, rot)
        pygame.draw.line(screen, SILVER, (int(round(self.x)), int(round(self.y))),
                         (int(round(self.x + self.radius * cos(self.theta))),
                          int(round(self.y + self.radius * sin(self.theta)))), 3 )
        pygame.draw.line(screen, SILVER, (self.x, self.y), \
                         (self.x + self.radius * cos(self.theta - PI/6),
                          self.y + self.radius * sin(self.theta - PI/6)), 3 )
        pygame.draw.line(screen, SILVER, (self.x, self.y), \
                         (self.x + self.radius * cos(self.theta + PI / 6),
                          self.y + self.radius * sin(self.theta + PI / 6)), 3 )

    def speedup_left(self):
        self.left_velocity += self.increase_factor

    def slowdown_left(self):
        self.left_velocity -= self.decrease_factor

    def speedup_right(self):
        self.right_velocity += self.increase_factor

    def slowdown_right(self):
        self.right_velocity -= self.decrease_factor

    def speedup_both(self):
        self.left_velocity += self.increase_factor
        self.right_velocity += self.increase_factor

    def slowdown_both(self):
        self.left_velocity -= self.decrease_factor
        self.right_velocity -= self.decrease_factor

    def stop_both(self):
        self.right_velocity = self.left_velocity = 0

    def update_icc(self):
        self.velocity = (self.left_velocity + self.right_velocity) / 2
        self.omega = (self.right_velocity - self.left_velocity) / (2 * self.radius)
        self.icc_radius = self.radius * ((self.left_velocity) + (self.right_velocity)) / (
                (self.right_velocity - self.left_velocity) + 0.0001)
        self.icc_centre_x = self.x - self.icc_radius * sin(self.theta)
        self.icc_centre_y = self.y + self.icc_radius * cos(self.theta)

    def move(self):
        prev_x = self.x
        prev_y = self.y
        prev_theta = self.theta
        self.collision = False
        self.collided_wall = None
        self.collision_num = 0
        self.blit_collision_info()
        if (self.left_velocity == self.right_velocity):
            self.theta += self.omega
            self.x += self.velocity * cos(self.theta)
            self.y += self.velocity * sin(self.theta)
        else:
            p = np.dot(np.array([[cos(self.omega), -sin(self.omega), 0],
                                 [sin(self.omega), cos(self.omega), 0],
                                 [0, 0, 1]]), \
                       np.array(
                           [self.icc_radius * sin(self.theta),  # self.x - self.icc_centre_x,
                            -self.icc_radius * cos(self.theta),  # self.y - self.icc_centre_y,
                            self.theta]))
            self.x = p[0] + self.icc_centre_x
            self.y = p[1] + self.icc_centre_y
            self.theta = p[2] + self.omega
            self.t += 1

        self.next_second()
        self.to_collide = False
        self.collision_detection(self.next_x, self.next_y, True)
        if (self.to_collide):
            self.color = GOLD
            self.x = prev_x
            self.y = prev_y
            self.theta = prev_theta
            self.slide()
            return

        # self.collision_detection()
        # if self.collision:
        #     self.x = prev_x
        #     self.y = prev_y
        #     # self.theta = prev_theta
        #     if self.collision_num > 2:
        #         self.theta += self.omega
        #         self.update_icc()
        #         self.draw()
        #         return
        #     else:
        #         self.slide()
        #         return
        self.draw()

    def next_second(self):
        self.next_x = None
        self.next_y = None
        self.next_theta = None
        if (self.left_velocity == self.right_velocity):
            self.next_x = self.x + self.velocity * cos(self.theta)
            self.next_y = self.y +  self.velocity * sin(self.theta)
            self.next_theta = self.theta + self.omega
        else:
            p = np.dot(np.array([[cos(self.omega), -sin(self.omega), 0],
                                 [sin(self.omega), cos(self.omega), 0],
                                 [0, 0, 1]]), \
                       np.array(
                           [self.icc_radius * sin(self.theta),  # self.x - self.icc_centre_x,
                            -self.icc_radius * cos(self.theta),  # self.y - self.icc_centre_y,
                            self.theta]))
            self.next_x = p[0] + self.icc_centre_x
            self.next_y = p[1] + self.icc_centre_y
            self.next_theta = p[2] + self.omega


    def slide(self):
        prev_x = self.x
        prev_y = self.y
        prev_theta = self.theta
        theta1 = self.collided_wall.angle
        direction = cos(theta1 - self.theta)
        self.theta += self.omega
        if direction <= -0.99 or direction > 0.99:
            self.collision = False
            p = np.dot(np.array([[cos(self.omega), -sin(self.omega), 0],
                                 [sin(self.omega), cos(self.omega), 0],
                                 [0, 0, 1]]), \
                       np.array(
                           [self.icc_radius * sin(self.theta),  # self.x - self.icc_centre_x,
                            -self.icc_radius * cos(self.theta),  # self.y - self.icc_centre_y,
                            self.theta]))
            self.x = p[0] + self.icc_centre_x
            self.y = p[1] + self.icc_centre_y
            self.theta = p[2] + self.omega
            self.t += 1
            self.draw()
            return
        if direction <= 0.0:
            self.x += self.velocity * - cos(theta1)
            self.y += self.velocity * - sin(theta1)
        if direction > 0.0:
            self.x += self.velocity * cos(theta1)
            self.y += self.velocity * sin(theta1)
        # self.to_collide = False
        # self.collision_detection(self.x, self.y, False)
        # if (self.to_collide):
        #     self.color = GOLD
        #     self.x = prev_x
        #     self.y = prev_y
        #     self.theta = prev_theta + self.omega
        #     self.update_icc()
        #     self.draw()
        #     return
        self.theta += self.omega

        self.update_icc()
        self.draw()
        # self.update_icc()

    def blit_collision_info(self):
        direction = None
        if self.collided_wall != None:
            theta1 = self.collided_wall.angle
            direction = cos(theta1 - self.theta)
        font = pygame.font.SysFont('FUTURA', 16)
        text = font.render(f"{self.collision}, {self.collision_num}, {direction}", True, BLACK, SILVER)
        textRect = text.get_rect()
        textRect.center = (self.x, self.y - 50)
        screen.blit(text, textRect)


    def message_display(self):
        messages = [f"l velocity: {self.left_velocity}", \
                    f"r velocity: {self.right_velocity}"]
        message = "\n".join(messages)
        text = font.render(message, True, (0, 128, 0))
        return text

    # def collision_detection(self):
    #     self.color = GREEN
    #     self.collision_num = 0
    #     for wall in walls:
    #         wall.color = GOLD
    #         perpendicular_distance = wall.get_perpendicular_distance(self.x, self.y)
    #         wall.dist = perpendicular_distance
    #         if (wall.hit == True):
    #             self.collision = True
    #             self.collided_wall = wall
    #             self.collision_num += 1

    def collision_detection(self, x, y, next = False):
        self.color = GREEN
        self.collision_num = 0
        self.walls_to_collide = []
        self.to_collide = False
        self.nearest_wall = None
        self.nearest_dist = None
        i = 10**10
        for wall in walls:
            wall.color = GOLD
            perpendicular_distance = wall.get_perpendicular_distance(x, y)
            print(f"per {perpendicular_distance}")
            if perpendicular_distance < i:
                i = perpendicular_distance
                self.nearest_wall = wall
                self.nearest_dist = i
            wall.dist = perpendicular_distance
            if (next == True and wall.hit == True):
                self.walls_to_collide.append(wall)
                self.to_collide = True
            if (wall.hit == True and next == False):
                self.collision = True
                self.to_collide = True
                self.collided_wall = wall
                self.collision_num += 1
        if next and len(self.walls_to_collide) > 0:
            self.collided_wall = self.walls_to_collide[0]
            self.collided_wall.color = BLACK

class Wall:
    def __init__(self, start_point, end_point, color):
        self.start_point = start_point
        self.end_point = end_point
        self.color = color
        self.m = None
        self.c = None
        self.angle = self.get_angle()
        self.dist = None
        self.hit = None

    def draw(self):
        pygame.draw.line(screen, self.color, self.start_point, self.end_point, 3)

    def get_perpendicular_distance(self, x, y):
        self.hit = False
        if (self.end_point[0] != self.start_point[0]):
            self.m = (self.end_point[1] - self.start_point[1]) / (self.end_point[0] - self.start_point[0])
            self.c = self.start_point[1] - (self.start_point[0]) * self.m
            # print(abs(self.m*x+self.c-y)/(np.sqrt(self.m*self.m + 1)))
            X = (x + self.m * y - self.m * self.c) / (self.m ** 2 + 1)
            Y = self.m * ( (x + self.m * y - self.m * self.c) / (self.m ** 2 + 1)) + self.c
            # pygame.draw.circle(screen, BLACK, (int(round((X))), int(round(Y))), 4)

            if (
                (min(self.end_point[0], self.start_point[0]) <= int(round(X)) <= max(self.start_point[0], self.end_point[0])) and \
                (min(self.end_point[1], self.start_point[1]) <= int(round(Y)) <= max(self.start_point[1], self.end_point[1])) and \
                (np.sqrt((X - x) ** 2 + (Y - y) ** 2) < 20)
            ):
                self.hit = True
                self.color = BLACK
                self.nearest_point = [X, Y]
            return abs(self.m * x + self.c - y) / (np.sqrt(self.m * self.m + 1))
        else:
            # print(abs(x-self.start_point[0]))
            X = self.start_point[0]
            Y = y
            self.nearest_point = [X, Y]
            # pygame.draw.circle(screen, BLACK, (int(round((X))), int(round(Y))), 4)
            if (
                (min(self.end_point[0], self.start_point[0]) <= int(round(X)) <= max(self.start_point[0], self.end_point[0])) and \
                (min(self.end_point[1], self.start_point[1]) <= int(round(Y)) <= max(self.start_point[1], self.end_point[1])) and \
                (np.sqrt((X - x) ** 2 + (Y - y) ** 2) < 20)
            ):
                self.hit = True
                self.color = BLACK
                self.nearest_point = [X, Y]
            return abs(y - self.start_point[1])


    def get_angle(self):

        if (self.end_point[0] != self.start_point[0]):
            self.m = (self.end_point[1] - self.start_point[1]) / (self.end_point[0] - self.start_point[0])
            return np.arctan(self.m)
        else:
            return PI / 2


def load_image(name):
    image = pygame.image.load(name)
    return image


class Player(pygame.sprite.Sprite):
    def __init__(self, pos, size=(200, 200)):
        super(Player, self).__init__()
        self.original_image = load_image('img/tireForward_0.png')
        # pygame.draw.line(self.original_image, (255, 0, 255), (size[0] / 2, 0), (size[0] / 2, size[1]), 3)
        # pygame.draw.line(self.original_image, (0, 255, 255), (size[1], 0), (0, size[1]), 3)
        self.image = self.original_image
        self.rect = self.image.get_rect()
        self.rect.center = pos
        self.angle = 0

    def update(self, x1, y1, theta, radius, shift):

        x2 = (x1 + radius * cos(theta))
        y2 = (y1 + radius * sin(theta))
        x2 += shift
        y2 += shift

        # self.image = pygame.transform.rotate(self.original_image, self.angle)
        self.angle = (-np.arctan2((y2 - y1), (x2 - x1)) * 180 / np.pi) - 90
        # x, y = self.rect.center  # Save its current center.
        self.rect = self.image.get_rect()  # Replace old rect with new rect.
        self.rect.center = (x2, y2)  # Put the new rect's center at old center.


def main():
    # player1 = Player(pos=(0, 0))
    # player2 = Player(pos=(0, 0))
    loopExit = True
    screen.blit(pygame.transform.scale(screen, (1000, 1000)), (0, 0))
    t = 0
    font = pygame.font.SysFont('Helvetica', 32)
    try:
        while loopExit:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    loopExit = False
                if event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_UP:
                        t = t + 1
                    elif event.key == pygame.K_w:
                        block.speedup_left()
                        block.update_icc()
                    elif event.key == pygame.K_s:
                        block.slowdown_left()
                        block.update_icc()
                    elif event.key == pygame.K_o:
                        block.speedup_right()
                        block.update_icc()
                    elif event.key == pygame.K_l:
                        block.slowdown_right()  # decrement of left wheel
                        block.update_icc()
                    elif event.key == pygame.K_x:
                        block.stop_both()  # zero both wheel speed
                        block.update_icc()
                    elif event.key == pygame.K_t:
                        block.speedup_both()  # increment both wheel speed
                        block.update_icc()
                    elif event.key == pygame.K_g:
                        block.slowdown_both()  # decrement both wheel speed
                        block.update_icc()
                    elif event.key == pygame.K_ESCAPE:
                        loopExit = False

            screen.fill(BLACK)
            text = font.render(f'L: {block.left_velocity}; R: {block.right_velocity}', True, GREEN, BLUE)
            text1 = font.render(f"{block.collision}. {()}", True, GREEN, BLUE)
            textRect = text.get_rect()
            textRect.center = (800 , 300 )
            textRect1 = text1.get_rect()
            textRect1.center = (800,850)
            print(block.theta)
            # player1.update(block.x, block.y, block.theta, block.radius, 20)
            # player2.update(block.x, block.y, block.theta, block.radius, 0)
            screen.fill((255, 255, 255))
            # screen.blit(player1.image, player1.rect)
            # screen.blit(player2.image, player2.rect)
            screen.blit(text, textRect)
            screen.blit(text1, textRect1)
            for w in walls:
                w.draw()
            block.move()
            block.draw_direction()
            block.draw_icc()
            # block.draw_direction(my_group)
            # block.draw_icc()
            # my_group.draw(screen)
            # pygame.display.flip()
            clock.tick(120)
            pygame.display.update()
        pygame.quit()
    except SystemExit:
        pygame.quit()


if __name__ == '__main__':
    pygame.init()
    width = 1000
    height = 1000
    clock = pygame.time.Clock()
    screen = pygame.display.set_mode((width, height), pygame.DOUBLEBUF | pygame.FULLSCREEN)
    walls = []
    east_border = Wall((width - 5 , 0), (width - 5  , height - 5 ), GREY)
    west_border = Wall((5 , 5 ), (5 , height - 5 ), GREY)
    south_border = Wall((5 , height - 5 ), (width - 5 , height - 5 ), GREY)
    north_border = Wall((5 , 5 ), (width - 5 , 5 ), GREY)
    # wall1 = Wall((250, 250), (750, 250), RED)
    # wall2 = Wall((750, 250), (750, 750), RED)
    # wall3 = Wall((750, 750), (250, 750), RED)
    # wall4 = Wall((250, 750), (250, 250), RED)
    # walls.append(wall1)
    # walls.append(wall2)
    # walls.append(wall3)
    # walls.append(wall4)
    walls.append(Wall((100, 200), (400, 300), GOLD))
    walls.append(Wall((600, 500), (800, 900), GOLD))
    walls.append((Wall((300, 500) , (300, 750), GOLD)))
    walls.append(Wall((600, 400), (600, 805), GOLD))
    walls.append(east_border)
    walls.append(west_border)
    walls.append(south_border)
    walls.append(north_border)
    block = Robot(520, 590 , 2 , 3 , 20 , walls)
    main()